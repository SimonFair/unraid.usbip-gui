#!/usr/bin/php
<?php
/* Copyright 2015, Guilherme Jardim
 * Copyright 2016-2020, Dan Landon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2,
 * as published by the Free Software Foundation.
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 */

$plugin = "unraid.usbip-gui";
$docroot = $docroot ?: @$_SERVER['DOCUMENT_ROOT'] ?: '/usr/local/emhttp';
require_once("$docroot/plugins/{$plugin}/include/lib_usbip.php");

$COMMAND = $argv[1];

if ($COMMAND != 'spindown') {
	$DEVNAME = (isset($_ENV['DEVNAME'])) ? $_ENV['DEVNAME'] : ( isset($argv[2]) ? $argv[2] : NULL );
	$DEVNAME = (file_exists($DEVNAME)) ? realpath($DEVNAME) : $DEVNAME;
} else {
	$DEVNAME = $argv[2];
}
$remove  = [];
#if (! $DEVNAME) die("Fail: device not defined.\n");

function usbip_modules_load() {
	global $plugin, $config;
	# Get Config file if load module is *YES process.

	$config_file = "/tmp/$plugin/config/$plugin.cfg";
	$cfg = is_file($config_file) ? @parse_ini_file($config_file, true) : array();
	$config = $cfg["Config"];

	
	if ($config["usbip_host"] == "yes") {
		usbip_log("info: Loading kernel module usbip_host");
		exec("modprobe usbip-host") ;
	}
	if ($config["vhci_hcd"] == "yes") {
		usbip_log("info: Loading kernel module vhci_hcd");
		exec("modprobe vhci_hcd") ;
	}

}

function usbipd_start() {
	$pid=shell_exec("pgrep usbipd") ;
	if ($pid!="") return ;
	usbip_log("Start usbipd");
	exec("usbipd -D --pid") ;	
}

function usbipd_stop() {
	$pid=shell_exec("pgrep usbipd") ;
	if ($pid==NULL) return ;
	usbip_log("Shutdown usbipd");	
	exec("killall usbipd") ;
}

function usbip_reload() {
	if (isset($_ENV['DEVLINKS'])) {
		foreach (explode(" ", $_ENV['DEVLINKS']) as $link) {
			get_udev_info($link, $_ENV, true);
		}
	}
}

function usbip_check_config() {
	global $config ;
	usbip_modules_load() ;
	$pid=shell_exec("pgrep -c  usbipd") ;
	if ($config["USBIPD"]=="enabled") {
		usbipd_start() ;
	} else {
		usbipd_stop() ;
	}		
}

function usb_dev_action($action, $serial)
{

	if ($action=="usb_add") {

		if (is_autoconnect($serial) == false ) return ;
		

	
		$vm = get_vm_config($serial, "VM");


		#$state = get_vm_state($vm) ;

		#if ($state != "shutoff") {
			$vm .= ";".$_ENV['BUSNUM'].";".$_ENV['DEVNUM'].";".$_ENV['ID_SERIAL'] ;	
	#	sleep(10) ;
		usbip_log("Info: 'rc.unraid.usbip-gui Autoconnect {$_ENV['ID_SERIAL']} {$_ENV['DEVNAME']} {$_ENV['BUSNUM']} {$_ENV['DEVNUM']}");
		vm_map_action($vm, "attach") ;
		#}
		#else { usbip_log("Info: 'rc.unraid.usbip-gui Autoconnect ignored VM not runnings {$_ENV['ID_SERIAL']} {$_ENV['DEVNAME']} {$_ENV['BUSNUM']} {$_ENV['DEVNUM']}");}

		
	}
}


switch ($COMMAND) {
	case 'modules_load':
		usbip_modules_load();
		break;

	case 'start_daemon':
		usbipd_start();
		break;

	case 'stop_daemon':
		usbipd_stop();
		break;

	case 'reload':
		usbip_reload();
		break;

	case 'refresh':
		break;

	case 'usb_add':
		usbip_log("Info: 'rc.unraid.usbip-gui {$argv[1]} {$_ENV['ID_SERIAL']} {$_ENV['DEVNAME']} {$_ENV['BUSNUM']} {$_ENV['DEVNUM']}");
		usb_dev_action($argv[1], $_ENV['ID_SERIAL']) ;
		break;

	case 'usb_remove':
		usbip_log("Info: 'rc.unraid.usbip-gui {$argv[1]} {$_ENV['ID_SERIAL']} {$_ENV['DEVNAME']} {$_ENV['BUSNUM']} {$_ENV['DEVNUM']} ");
		break;

	case 'check_config':
		usbip_check_config() ;
		break;	

	default:
		usbip_log("Error: 'rc.unraid.usbip-gui {$argv[1]} {$argv[2]}' not understood");
		usbip_log("rc.unraid.usbip-gui usage: 'modules_load','start_daemon','stop_daemon', 'reload', 'refresh', 'check_config");
		exit(0);
		break;
}
?>
